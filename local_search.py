from random import *
import numpy as np
import matplotlib.pyplot as plt
from copy import deepcopy

# returns True with probability p
def coin_flip(p):
    return random() <= p

def get_mutation_index(assignment):
    semester_index = randint(0, 4)
    course_index = randint(0, len(assignment[random_semester]))

    return (semester_index, course_index)

def pick_course(domain):
    return choice(domain)

# A state is a list of value indices.
# Randomly picks value indices until the weight limit is reached
def get_random_successor(assignment, domain):

    # pick semester & course to mutate
    semester_index, course_index = get_mutation_index(assignment)

    # remove course from assignment
    removed_course = assignment[semester_index][course_index]

    # add back courses with in this timeslot
    good_timeslot = courses[removed_course]["timeslot"]
    for course in timeslots[good_timeslot]:
        domain.append(course)

    # pick

    state = []
    curr_wt = 0
    curr_val = 0

    # randomizes the order that values are chosen in
    randomized_draw = range(N)
    random.shuffle(randomized_draw)

    i = 0

    while True:
        choice = randomized_draw[i]

        if curr_wt + w[choice] <= W:
            state.append(choice)
            curr_wt += w[choice]
            curr_val += v[choice]
            i += 1

        else:
            return (state, curr_wt, curr_val)

# A state is a list of value indices. A neighbor state is generated by:
# (a) adding a randomly chosen value index to the state
# (b) replacing a randomly chosen value index already in the state
def get_neighbor(state, curr_wt, curr_val):
    neighbor = deepcopy(state)
    unused_indices = filter(lambda x: x not in state, range(N))

    possible_to_add = True

    while True:
        if possible_to_add and coin_flip(0.5):
            # try to add a value index to the state
            possibilities = filter(lambda x: curr_wt + w[x] <= W, \
                                        unused_indices)

            possible_to_add = (len(possibilities) > 0)

            if possible_to_add:
                add_index = random.choice(possibilities)
                neighbor.append(add_index)
                return (neighbor, curr_wt + w[add_index], curr_val + v[add_index])

        else:
            random_state_index = random.randint(0, len(state) - 1)
            replaced_index = state[random_state_index]

            possibilities = filter(\
                    lambda x: curr_wt - w[replaced_index] + w[x] <= W, \
                        unused_indices)

            if len(possibilities) > 0:
                replacement = random.choice(possibilities)
                neighbor[random_state_index] = replacement

                return (neighbor, \
                        curr_wt - w[replaced_index] + w[replacement], \
                        curr_val - v[replaced_index] + v[replacement])


def simulated_annealing():
    # YOUR CODE HERE
    trace = []
    wt_trace = []

    curr_state, curr_wt, curr_val = get_random_state()

    T = 1.0
    alpha = 0.99

    for t in xrange(10000):
        neighbor, neighbor_wt, neighbor_val = get_neighbor(curr_state, curr_wt, curr_val)
        delta_E = (neighbor_val - curr_val)/curr_val # normalization
        switch_probability = np.exp(delta_E/T) # used only when delta_E < 0

        # switch to neighbor if its advantageous or random move
        if delta_E > 0 or coin_flip(switch_probability):
            curr_state, curr_wt, curr_val = neighbor, neighbor_wt, neighbor_val

        trace.append(curr_val)
        wt_trace.append(curr_wt)
        T = alpha * T

    # print stats
    print("SA Algorithm: Value:{}, Weight:{}\nBag:{}".format(curr_val, curr_wt, curr_state))
    # return a trace of values resulting from your simulated annealing
    return trace

if __name__ == "__main__":
    # Greedy result is maximize v/w
    vw_ratio = sorted(map(lambda x: (x, 1.*v[x]/w[x]), range(N)), key= lambda x: -x[1])
    greedy_val = 0
    greedy_weight = 0
    greedy_bag = []
    index = 0
    while greedy_weight + w[vw_ratio[index][0]] < W:
        greedy_val += v[vw_ratio[index][0]]
        greedy_weight += w[vw_ratio[index][0]]
        greedy_bag += [vw_ratio[index][0]]
        index += 1

    print("Greedy Algorithm:\nValue:{}, Weight:{}\nBag:{}".format(greedy_val, greedy_weight, greedy_bag))
    SA_trace = simulated_annealing()
    plt.plot([greedy_val]*len(SA_trace), label="Greedy")
    plt.plot(SA_trace, label="SA")
    plt.legend(bbox_to_anchor=(0., 1.02, 1., .102), loc=3,
           ncol=2, mode="expand", borderaxespad=0.)
    plt.show()
Â© 2017 GitHub, Inc.
Terms
Privacy
Security
Status
Help
Contact GitHub
API
Training
Shop
Blog
About
